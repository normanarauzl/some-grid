{"remainingRequest":"/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/ag-grid-community/dist/lib/rendering/features/setLeftFeature.js","dependencies":[{"path":"/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/ag-grid-community/dist/lib/rendering/features/setLeftFeature.js","mtime":499162500000},{"path":"/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/cache-loader/dist/cjs.js","mtime":1538485928640},{"path":"/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.0.0\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __extends = /*@__PURE__*/ require(\"tslib\").__extends;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"../../utils\");\nvar column_1 = require(\"../../entities/column\");\nvar beanStub_1 = require(\"../../context/beanStub\");\nvar constants_1 = require(\"../../constants\");\nvar SetLeftFeature = /*@__PURE__*/ (function (_super) {\n    __extends(SetLeftFeature, _super);\n    function SetLeftFeature(columnOrGroup, eCell, beans, colsSpanning) {\n        var _this = _super.call(this) || this;\n        _this.columnOrGroup = columnOrGroup;\n        _this.eCell = eCell;\n        _this.colsSpanning = colsSpanning;\n        _this.beans = beans;\n        _this.printLayout = beans.gridOptionsWrapper.getDomLayout() === constants_1.Constants.DOM_LAYOUT_PRINT;\n        return _this;\n    }\n    SetLeftFeature.prototype.setColsSpanning = function (colsSpanning) {\n        this.colsSpanning = colsSpanning;\n        this.onLeftChanged();\n    };\n    SetLeftFeature.prototype.getColumnOrGroup = function () {\n        if (this.beans.gridOptionsWrapper.isEnableRtl() && this.colsSpanning) {\n            return this.colsSpanning[this.colsSpanning.length - 1];\n        }\n        else {\n            return this.columnOrGroup;\n        }\n    };\n    SetLeftFeature.prototype.init = function () {\n        this.addDestroyableEventListener(this.columnOrGroup, column_1.Column.EVENT_LEFT_CHANGED, this.onLeftChanged.bind(this));\n        this.setLeftFirstTime();\n    };\n    SetLeftFeature.prototype.setLeftFirstTime = function () {\n        var suppressMoveAnimation = this.beans.gridOptionsWrapper.isSuppressColumnMoveAnimation();\n        var oldLeftExists = utils_1.Utils.exists(this.columnOrGroup.getOldLeft());\n        var animateColumnMove = this.beans.columnAnimationService.isActive() && oldLeftExists && !suppressMoveAnimation;\n        if (animateColumnMove) {\n            this.animateInLeft();\n        }\n        else {\n            this.onLeftChanged();\n        }\n    };\n    SetLeftFeature.prototype.animateInLeft = function () {\n        var _this = this;\n        var left = this.getColumnOrGroup().getLeft();\n        var oldLeft = this.getColumnOrGroup().getOldLeft();\n        this.setLeft(oldLeft);\n        // we must keep track of the left we want to set to, as this would otherwise lead to a race\n        // condition, if the user changed the left value many times in one VM turn, then we want to make\n        // make sure the actualLeft we set in the timeout below (in the next VM turn) is the correct left\n        // position. eg if user changes column position twice, then setLeft() below executes twice in next\n        // VM turn, but only one (the correct one) should get applied.\n        this.actualLeft = left;\n        this.beans.columnAnimationService.executeNextVMTurn(function () {\n            // test this left value is the latest one to be applied, and if not, do nothing\n            if (_this.actualLeft === left) {\n                _this.setLeft(left);\n            }\n        });\n    };\n    SetLeftFeature.prototype.onLeftChanged = function () {\n        var colOrGroup = this.getColumnOrGroup();\n        var left = colOrGroup.getLeft();\n        this.actualLeft = this.modifyLeftForPrintLayout(colOrGroup, left);\n        this.setLeft(this.actualLeft);\n    };\n    SetLeftFeature.prototype.modifyLeftForPrintLayout = function (colOrGroup, leftPosition) {\n        if (!this.printLayout) {\n            return leftPosition;\n        }\n        if (colOrGroup.getPinned() === column_1.Column.PINNED_LEFT) {\n            return leftPosition;\n        }\n        else if (colOrGroup.getPinned() === column_1.Column.PINNED_RIGHT) {\n            var leftWidth = this.beans.columnController.getPinnedLeftContainerWidth();\n            var bodyWidth = this.beans.columnController.getBodyContainerWidth();\n            return leftWidth + bodyWidth + leftPosition;\n        }\n        else {\n            // is in body\n            var leftWidth = this.beans.columnController.getPinnedLeftContainerWidth();\n            return leftWidth + leftPosition;\n        }\n    };\n    SetLeftFeature.prototype.setLeft = function (value) {\n        // if the value is null, then that means the column is no longer\n        // displayed. there is logic in the rendering to fade these columns\n        // out, so we don't try and change their left positions.\n        if (utils_1.Utils.exists(value)) {\n            this.eCell.style.left = value + 'px';\n        }\n    };\n    return SetLeftFeature;\n}(beanStub_1.BeanStub));\nexports.SetLeftFeature = SetLeftFeature;\n",null]}