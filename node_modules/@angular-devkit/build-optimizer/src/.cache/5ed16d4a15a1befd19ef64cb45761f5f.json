{"remainingRequest":"/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/ag-grid-enterprise/dist/lib/rowModels/serverSide/serverSideCache.js","dependencies":[{"path":"/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/ag-grid-enterprise/dist/lib/rowModels/serverSide/serverSideCache.js","mtime":499162500000},{"path":"/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/cache-loader/dist/cjs.js","mtime":1538485928640},{"path":"/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["// ag-grid-enterprise v19.0.0\n\"use strict\";\nvar __extends = /*@__PURE__*/ require(\"tslib\").__extends;\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nvar __param = /*@__PURE__*/ require(\"tslib\").__param;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ag_grid_community_1 = require(\"ag-grid-community\");\nvar serverSideBlock_1 = require(\"./serverSideBlock\");\nvar ServerSideCache = /*@__PURE__*/ (function (_super) {\n    __extends(ServerSideCache, _super);\n    function ServerSideCache(cacheParams, parentRowNode) {\n        var _this = _super.call(this, cacheParams) || this;\n        // this will always be zero for the top level cache only,\n        // all the other ones change as the groups open and close\n        _this.displayIndexStart = 0;\n        _this.displayIndexEnd = 0; // not sure if setting this one to zero is necessary\n        _this.cacheTop = 0;\n        _this.blockHeights = {};\n        _this.parentRowNode = parentRowNode;\n        return _this;\n    }\n    ServerSideCache.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('ServerSideCache');\n    };\n    ServerSideCache.prototype.init = function () {\n        _super.prototype.init.call(this);\n    };\n    ServerSideCache.prototype.getRowBounds = function (index) {\n        var _this = this;\n        this.logger.log(\"getRowBounds(\" + index + \")\");\n        // we return null if row not found\n        var result;\n        var blockFound = false;\n        var lastBlock;\n        this.forEachBlockInOrder(function (block) {\n            if (blockFound)\n                return;\n            if (block.isDisplayIndexInBlock(index)) {\n                result = block.getRowBounds(index, _this.getVirtualRowCount());\n                blockFound = true;\n            }\n            else if (block.isBlockBefore(index)) {\n                lastBlock = block;\n            }\n        });\n        if (!blockFound) {\n            var nextRowTop = void 0;\n            var nextRowIndex = void 0;\n            if (lastBlock) {\n                nextRowTop = lastBlock.getBlockTop() + lastBlock.getBlockHeight();\n                nextRowIndex = lastBlock.getDisplayIndexEnd();\n            }\n            else {\n                nextRowTop = this.cacheTop;\n                nextRowIndex = this.displayIndexStart;\n            }\n            var rowsBetween = index - nextRowIndex;\n            result = {\n                rowHeight: this.cacheParams.rowHeight,\n                rowTop: nextRowTop + rowsBetween * this.cacheParams.rowHeight\n            };\n        }\n        // NOTE: what about purged blocks\n        this.logger.log(\"getRowBounds(\" + index + \"), result = \" + result);\n        return result;\n    };\n    ServerSideCache.prototype.destroyBlock = function (block) {\n        _super.prototype.destroyBlock.call(this, block);\n    };\n    ServerSideCache.prototype.getRowIndexAtPixel = function (pixel) {\n        var _this = this;\n        this.logger.log(\"getRowIndexAtPixel(\" + pixel + \")\");\n        // we return null if row not found\n        var result;\n        var blockFound = false;\n        var lastBlock;\n        this.forEachBlockInOrder(function (block) {\n            if (blockFound)\n                return;\n            if (block.isPixelInRange(pixel)) {\n                result = block.getRowIndexAtPixel(pixel, _this.getVirtualRowCount());\n                blockFound = true;\n            }\n            else if (block.getBlockTop() > pixel) {\n                lastBlock = block;\n            }\n        });\n        if (!blockFound) {\n            var nextRowTop = void 0;\n            var nextRowIndex = void 0;\n            if (lastBlock) {\n                nextRowTop = lastBlock.getBlockTop() + lastBlock.getBlockHeight();\n                nextRowIndex = lastBlock.getDisplayIndexEnd();\n            }\n            else {\n                nextRowTop = this.cacheTop;\n                nextRowIndex = this.displayIndexStart;\n            }\n            var pixelsBetween = pixel - nextRowTop;\n            var rowsBetween = (pixelsBetween / this.cacheParams.rowHeight) | 0;\n            result = nextRowIndex + rowsBetween;\n        }\n        var lastAllowedIndex = this.getDisplayIndexEnd() - 1;\n        if (result > lastAllowedIndex) {\n            result = lastAllowedIndex;\n        }\n        //NOTE: purged\n        this.logger.log(\"getRowIndexAtPixel(\" + pixel + \") result = \" + result);\n        return result;\n    };\n    ServerSideCache.prototype.clearRowTops = function () {\n        var _this = this;\n        this.forEachBlockInOrder(function (block) { return block.clearRowTops(_this.getVirtualRowCount()); });\n    };\n    ServerSideCache.prototype.setDisplayIndexes = function (displayIndexSeq, nextRowTop) {\n        var _this = this;\n        this.displayIndexStart = displayIndexSeq.peek();\n        this.cacheTop = nextRowTop.value;\n        var lastBlockId = -1;\n        this.forEachBlockInOrder(function (currentBlock, blockId) {\n            // if we skipped blocks, then we need to skip the row indexes. we assume that all missing\n            // blocks are made up of closed RowNodes only (if they were groups), as we never expire from\n            // the cache if any row nodes are open.\n            var blocksSkippedCount = blockId - lastBlockId - 1;\n            var rowsSkippedCount = blocksSkippedCount * _this.cacheParams.blockSize;\n            if (rowsSkippedCount > 0) {\n                displayIndexSeq.skip(rowsSkippedCount);\n            }\n            for (var i = 1; i <= blocksSkippedCount; i++) {\n                var blockToAddId = blockId - i;\n                if (ag_grid_community_1._.exists(_this.blockHeights[blockToAddId])) {\n                    nextRowTop.value += _this.blockHeights[blockToAddId];\n                }\n                else {\n                    nextRowTop.value += _this.cacheParams.blockSize * _this.cacheParams.rowHeight;\n                }\n            }\n            lastBlockId = blockId;\n            currentBlock.setDisplayIndexes(displayIndexSeq, _this.getVirtualRowCount(), nextRowTop);\n            _this.blockHeights[blockId] = currentBlock.getBlockHeight();\n        });\n        // if any blocks missing at the end, need to increase the row index for them also\n        // eg if block size = 10, we have total rows of 25 (indexes 0 .. 24), but first 2 blocks loaded (because\n        // last row was ejected from cache), then:\n        // lastVisitedRow = 19, virtualRowCount = 25, rows not accounted for = 5 (24 - 19)\n        var lastVisitedRow = ((lastBlockId + 1) * this.cacheParams.blockSize) - 1;\n        var rowCount = this.getVirtualRowCount();\n        var rowsNotAccountedFor = rowCount - lastVisitedRow - 1;\n        if (rowsNotAccountedFor > 0) {\n            displayIndexSeq.skip(rowsNotAccountedFor);\n            nextRowTop.value += rowsNotAccountedFor * this.cacheParams.rowHeight;\n        }\n        this.displayIndexEnd = displayIndexSeq.peek();\n        this.cacheHeight = nextRowTop.value - this.cacheTop;\n    };\n    // gets called in a) init() above and b) by the grid\n    ServerSideCache.prototype.getRow = function (displayRowIndex, dontCreateBlock) {\n        var _this = this;\n        if (dontCreateBlock === void 0) {\n            dontCreateBlock = false;\n        }\n        // this can happen if asking for a row that doesn't exist in the model,\n        // eg if a cell range is selected, and the user filters so rows no longer\n        // exist\n        if (!this.isDisplayIndexInCache(displayRowIndex)) {\n            return null;\n        }\n        // if we have the block, then this is the block\n        var block = null;\n        // this is the last block that we have BEFORE the right block\n        var beforeBlock = null;\n        this.forEachBlockInOrder(function (currentBlock) {\n            if (currentBlock.isDisplayIndexInBlock(displayRowIndex)) {\n                block = currentBlock;\n            }\n            else if (currentBlock.isBlockBefore(displayRowIndex)) {\n                // this will get assigned many times, but the last time will\n                // be the closest block to the required block that is BEFORE\n                beforeBlock = currentBlock;\n            }\n        });\n        // when we are moving rows around, we don't want to trigger loads\n        if (ag_grid_community_1._.missing(block) && dontCreateBlock) {\n            return null;\n        }\n        // if block not found, we need to load it\n        if (ag_grid_community_1._.missing(block)) {\n            var blockNumber = void 0;\n            var displayIndexStart_1;\n            var nextRowTop = void 0;\n            // because missing blocks are always fully closed, we can work out\n            // the start index of the block we want by hopping from the closest block,\n            // as we know the row count in closed blocks is equal to the page size\n            if (beforeBlock) {\n                blockNumber = beforeBlock.getBlockNumber() + 1;\n                displayIndexStart_1 = beforeBlock.getDisplayIndexEnd();\n                nextRowTop = beforeBlock.getBlockHeight() + beforeBlock.getBlockTop();\n                var isInRange = function () {\n                    return displayRowIndex >= displayIndexStart_1 && displayRowIndex < (displayIndexStart_1 + _this.cacheParams.blockSize);\n                };\n                while (!isInRange()) {\n                    displayIndexStart_1 += this.cacheParams.blockSize;\n                    var cachedBlockHeight = this.blockHeights[blockNumber];\n                    if (ag_grid_community_1._.exists(cachedBlockHeight)) {\n                        nextRowTop += cachedBlockHeight;\n                    }\n                    else {\n                        nextRowTop += this.cacheParams.rowHeight * this.cacheParams.blockSize;\n                    }\n                    blockNumber++;\n                }\n            }\n            else {\n                var localIndex = displayRowIndex - this.displayIndexStart;\n                blockNumber = Math.floor(localIndex / this.cacheParams.blockSize);\n                displayIndexStart_1 = this.displayIndexStart + (blockNumber * this.cacheParams.blockSize);\n                nextRowTop = this.cacheTop + (blockNumber * this.cacheParams.blockSize * this.cacheParams.rowHeight);\n            }\n            block = this.createBlock(blockNumber, displayIndexStart_1, { value: nextRowTop });\n            this.logger.log(\"block missing, rowIndex = \" + displayRowIndex + \", creating #\" + blockNumber + \", displayIndexStart = \" + displayIndexStart_1);\n        }\n        var rowNode = block.getRow(displayRowIndex);\n        return rowNode;\n    };\n    ServerSideCache.prototype.createBlock = function (blockNumber, displayIndex, nextRowTop) {\n        var newBlock = new serverSideBlock_1.ServerSideBlock(blockNumber, this.parentRowNode, this.cacheParams, this);\n        this.context.wireBean(newBlock);\n        var displayIndexSequence = new ag_grid_community_1.NumberSequence(displayIndex);\n        newBlock.setDisplayIndexes(displayIndexSequence, this.getVirtualRowCount(), nextRowTop);\n        this.postCreateBlock(newBlock);\n        return newBlock;\n    };\n    ServerSideCache.prototype.getDisplayIndexEnd = function () {\n        return this.displayIndexEnd;\n    };\n    ServerSideCache.prototype.isDisplayIndexInCache = function (displayIndex) {\n        if (this.getVirtualRowCount() === 0) {\n            return false;\n        }\n        return displayIndex >= this.displayIndexStart && displayIndex < this.displayIndexEnd;\n    };\n    ServerSideCache.prototype.getChildCache = function (keys) {\n        var _this = this;\n        if (ag_grid_community_1._.missingOrEmpty(keys)) {\n            return this;\n        }\n        var nextKey = keys[0];\n        var nextServerSideCache = null;\n        this.forEachBlockInOrder(function (block) {\n            // callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number\n            block.forEachNodeShallow(function (rowNode) {\n                if (rowNode.key === nextKey) {\n                    nextServerSideCache = rowNode.childrenCache;\n                }\n            }, new ag_grid_community_1.NumberSequence(), _this.getVirtualRowCount());\n        });\n        if (nextServerSideCache) {\n            var keyListForNextLevel = keys.slice(1, keys.length);\n            return nextServerSideCache.getChildCache(keyListForNextLevel);\n        }\n        else {\n            return null;\n        }\n    };\n    ServerSideCache.prototype.isPixelInRange = function (pixel) {\n        if (this.getVirtualRowCount() === 0) {\n            return false;\n        }\n        return pixel >= this.cacheTop && pixel < (this.cacheTop + this.cacheHeight);\n    };\n    ServerSideCache.prototype.removeFromCache = function (items) {\n        var _this = this;\n        // create map of id's for quick lookup\n        var itemsToDeleteById = {};\n        var idForNodeFunc = this.gridOptionsWrapper.getRowNodeIdFunc();\n        items.forEach(function (item) {\n            var id = idForNodeFunc(item);\n            itemsToDeleteById[id] = item;\n        });\n        var deletedCount = 0;\n        this.forEachBlockInOrder(function (block) {\n            var startRow = block.getStartRow();\n            var endRow = block.getEndRow();\n            var deletedCountFromThisBlock = 0;\n            for (var rowIndex = startRow; rowIndex < endRow; rowIndex++) {\n                var rowNode = block.getRowUsingLocalIndex(rowIndex, true);\n                if (!rowNode) {\n                    continue;\n                }\n                var deleteThisRow = !!itemsToDeleteById[rowNode.id];\n                if (deleteThisRow) {\n                    deletedCountFromThisBlock++;\n                    deletedCount++;\n                    block.setDirty();\n                    rowNode.clearRowTop();\n                    continue;\n                }\n                // if rows were deleted, then we need to move this row node to\n                // it's new location\n                if (deletedCount > 0) {\n                    block.setDirty();\n                    var newIndex = rowIndex - deletedCount;\n                    var blockId = Math.floor(newIndex / _this.cacheParams.blockSize);\n                    var blockToInsert = _this.getBlock(blockId);\n                    if (blockToInsert) {\n                        blockToInsert.setRowNode(newIndex, rowNode);\n                    }\n                }\n            }\n            if (deletedCountFromThisBlock > 0) {\n                for (var i = deletedCountFromThisBlock; i > 0; i--) {\n                    block.setBlankRowNode(endRow - i);\n                }\n            }\n        });\n        if (this.isMaxRowFound()) {\n            this.hack_setVirtualRowCount(this.getVirtualRowCount() - deletedCount);\n        }\n        this.onCacheUpdated();\n        var event = {\n            type: ag_grid_community_1.Events.EVENT_ROW_DATA_UPDATED,\n            api: this.gridOptionsWrapper.getApi(),\n            columnApi: this.gridOptionsWrapper.getColumnApi()\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ServerSideCache.prototype.addToCache = function (items, indexToInsert) {\n        var _this = this;\n        var newNodes = [];\n        this.forEachBlockInReverseOrder(function (block) {\n            var pageEndRow = block.getEndRow();\n            // if the insertion is after this page, then this page is not impacted\n            if (pageEndRow <= indexToInsert) {\n                return;\n            }\n            _this.moveItemsDown(block, indexToInsert, items.length);\n            var newNodesThisPage = _this.insertItems(block, indexToInsert, items);\n            newNodesThisPage.forEach(function (rowNode) { return newNodes.push(rowNode); });\n        });\n        if (this.isMaxRowFound()) {\n            this.hack_setVirtualRowCount(this.getVirtualRowCount() + items.length);\n        }\n        this.onCacheUpdated();\n        var event = {\n            type: ag_grid_community_1.Events.EVENT_ROW_DATA_UPDATED,\n            api: this.gridOptionsWrapper.getApi(),\n            columnApi: this.gridOptionsWrapper.getColumnApi()\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ServerSideCache.prototype.moveItemsDown = function (block, moveFromIndex, moveCount) {\n        var startRow = block.getStartRow();\n        var endRow = block.getEndRow();\n        var indexOfLastRowToMove = moveFromIndex + moveCount;\n        // all rows need to be moved down below the insertion index\n        for (var currentRowIndex = endRow - 1; currentRowIndex >= startRow; currentRowIndex--) {\n            // don't move rows at or before the insertion index\n            if (currentRowIndex < indexOfLastRowToMove) {\n                continue;\n            }\n            var indexOfNodeWeWant = currentRowIndex - moveCount;\n            var nodeForThisIndex = this.getRow(indexOfNodeWeWant, true);\n            if (nodeForThisIndex) {\n                block.setRowNode(currentRowIndex, nodeForThisIndex);\n            }\n            else {\n                block.setBlankRowNode(currentRowIndex);\n                block.setDirty();\n            }\n        }\n    };\n    ServerSideCache.prototype.insertItems = function (block, indexToInsert, items) {\n        var pageStartRow = block.getStartRow();\n        var pageEndRow = block.getEndRow();\n        var newRowNodes = [];\n        // next stage is insert the rows into this page, if applicable\n        for (var index = 0; index < items.length; index++) {\n            var rowIndex = indexToInsert + index;\n            var currentRowInThisPage = rowIndex >= pageStartRow && rowIndex < pageEndRow;\n            if (currentRowInThisPage) {\n                var dataItem = items[index];\n                var newRowNode = block.setNewData(rowIndex, dataItem);\n                newRowNodes.push(newRowNode);\n            }\n        }\n        return newRowNodes;\n    };\n    ServerSideCache.prototype.refreshCacheAfterSort = function (changedColumnsInSort, rowGroupColIds) {\n        var _this = this;\n        var level = this.parentRowNode.level + 1;\n        var grouping = level < this.cacheParams.rowGroupCols.length;\n        var shouldPurgeCache;\n        if (grouping) {\n            var groupColVo = this.cacheParams.rowGroupCols[level];\n            var groupField = groupColVo.field;\n            var rowGroupBlock = rowGroupColIds.indexOf(groupField) > -1;\n            var sortingByGroup = changedColumnsInSort.indexOf(groupField) > -1;\n            shouldPurgeCache = rowGroupBlock && sortingByGroup;\n        }\n        else {\n            shouldPurgeCache = true;\n        }\n        if (shouldPurgeCache) {\n            this.purgeCache();\n        }\n        else {\n            this.forEachBlockInOrder(function (block) {\n                if (block.isGroupLevel()) {\n                    var callback = function (rowNode) {\n                        var nextCache = rowNode.childrenCache;\n                        if (nextCache) {\n                            nextCache.refreshCacheAfterSort(changedColumnsInSort, rowGroupColIds);\n                        }\n                    };\n                    block.forEachNodeShallow(callback, new ag_grid_community_1.NumberSequence(), _this.getVirtualRowCount());\n                }\n            });\n        }\n    };\n    __decorate([\n        ag_grid_community_1.Autowired('eventService'),\n        __metadata(\"design:type\", ag_grid_community_1.EventService)\n    ], ServerSideCache.prototype, \"eventService\", void 0);\n    __decorate([\n        ag_grid_community_1.Autowired('context'),\n        __metadata(\"design:type\", ag_grid_community_1.Context)\n    ], ServerSideCache.prototype, \"context\", void 0);\n    __decorate([\n        ag_grid_community_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", ag_grid_community_1.GridOptionsWrapper)\n    ], ServerSideCache.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        __param(0, ag_grid_community_1.Qualifier('loggerFactory')),\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [ag_grid_community_1.LoggerFactory]),\n        __metadata(\"design:returntype\", void 0)\n    ], ServerSideCache.prototype, \"setBeans\", null);\n    __decorate([\n        ag_grid_community_1.PostConstruct,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], ServerSideCache.prototype, \"init\", null);\n    return ServerSideCache;\n}(ag_grid_community_1.RowNodeCache));\nexports.ServerSideCache = ServerSideCache;\n",null]}