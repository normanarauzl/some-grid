{"remainingRequest":"/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/ag-grid-enterprise/dist/lib/rowStages/pivotColDefService.js","dependencies":[{"path":"/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/ag-grid-enterprise/dist/lib/rowStages/pivotColDefService.js","mtime":499162500000},{"path":"/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/cache-loader/dist/cjs.js","mtime":1538485928640},{"path":"/home/vdsancheza/Documents/MeanStack/some-grid/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["// ag-grid-enterprise v19.0.0\n\"use strict\";\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ag_grid_community_1 = require(\"ag-grid-community\");\nvar PivotColDefService = /*@__PURE__*/ (function () {\n    function PivotColDefService() {\n    }\n    PivotColDefService.prototype.createPivotColumnDefs = function (uniqueValues) {\n        // this is passed to the columnController, to configure the columns and groups we show\n        var pivotColumnGroupDefs = [];\n        // this is used by the aggregation stage, to do the aggregation based on the pivot columns\n        var pivotColumnDefs = [];\n        var pivotColumns = this.columnController.getPivotColumns();\n        var valueColumns = this.columnController.getValueColumns();\n        var levelsDeep = pivotColumns.length;\n        var columnIdSequence = new ag_grid_community_1.NumberSequence();\n        this.recursivelyAddGroup(pivotColumnGroupDefs, pivotColumnDefs, 1, uniqueValues, [], columnIdSequence, levelsDeep, pivotColumns);\n        this.addRowGroupTotals(pivotColumnGroupDefs, pivotColumnDefs, valueColumns, pivotColumns, columnIdSequence);\n        this.addPivotTotalsToGroups(pivotColumnGroupDefs, pivotColumnDefs, columnIdSequence);\n        // we clone, so the colDefs in pivotColumnsGroupDefs and pivotColumnDefs are not shared. this is so that\n        // any changes the user makes (via processSecondaryColumnDefinitions) don't impact the internal aggregations,\n        // as these use the col defs also\n        var pivotColumnDefsClone = pivotColumnDefs.map(function (colDef) { return ag_grid_community_1.Utils.cloneObject(colDef); });\n        return {\n            pivotColumnGroupDefs: pivotColumnGroupDefs,\n            pivotColumnDefs: pivotColumnDefsClone\n        };\n    };\n    // parentChildren - the list of colDefs we are adding to\n    // @index - how far the column is from the top (also same as pivotKeys.length)\n    // @uniqueValues - the values for which we should create a col for\n    // @pivotKeys - the keys for the pivot, eg if pivoting on {Language,Country} then could be {English,Ireland}\n    PivotColDefService.prototype.recursivelyAddGroup = function (parentChildren, pivotColumnDefs, index, uniqueValues, pivotKeys, columnIdSequence, levelsDeep, primaryPivotColumns) {\n        var _this = this;\n        ag_grid_community_1.Utils.iterateObject(uniqueValues, function (key, value) {\n            var newPivotKeys = pivotKeys.slice(0);\n            newPivotKeys.push(key);\n            var createGroup = index !== levelsDeep;\n            if (createGroup) {\n                var groupDef = {\n                    children: [],\n                    headerName: key,\n                    pivotKeys: newPivotKeys,\n                    columnGroupShow: 'open',\n                    groupId: 'pivot' + columnIdSequence.next()\n                };\n                parentChildren.push(groupDef);\n                _this.recursivelyAddGroup(groupDef.children, pivotColumnDefs, index + 1, value, newPivotKeys, columnIdSequence, levelsDeep, primaryPivotColumns);\n            }\n            else {\n                var measureColumns = _this.columnController.getValueColumns();\n                var valueGroup_1 = {\n                    children: [],\n                    headerName: key,\n                    pivotKeys: newPivotKeys,\n                    columnGroupShow: 'open',\n                    groupId: 'pivot' + columnIdSequence.next()\n                };\n                // if no value columns selected, then we insert one blank column, so the user at least sees columns\n                // rendered. otherwise the grid would render with no columns (just empty groups) which would give the\n                // impression that the grid is broken\n                if (measureColumns.length === 0) {\n                    // this is the blank column, for when no value columns enabled.\n                    var colDef_1 = _this.createColDef(null, '-', newPivotKeys, columnIdSequence);\n                    valueGroup_1.children.push(colDef_1);\n                    pivotColumnDefs.push(colDef_1);\n                }\n                else {\n                    measureColumns.forEach(function (measureColumn) {\n                        var columnName = _this.columnController.getDisplayNameForColumn(measureColumn, 'header');\n                        var colDef = _this.createColDef(measureColumn, columnName, newPivotKeys, columnIdSequence);\n                        colDef.columnGroupShow = 'open';\n                        valueGroup_1.children.push(colDef);\n                        pivotColumnDefs.push(colDef);\n                    });\n                }\n                parentChildren.push(valueGroup_1);\n            }\n        });\n        // sort by either user provided comparator, or our own one\n        var colDef = primaryPivotColumns[index - 1].getColDef();\n        var userComparator = colDef.pivotComparator;\n        var comparator = this.headerNameComparator.bind(this, userComparator);\n        parentChildren.sort(comparator);\n    };\n    PivotColDefService.prototype.addPivotTotalsToGroups = function (pivotColumnGroupDefs, pivotColumnDefs, columnIdSequence) {\n        var _this = this;\n        if (!this.gridOptionsWrapper.getPivotColumnGroupTotals())\n            return;\n        var insertAfter = this.gridOptionsWrapper.getPivotColumnGroupTotals() === 'after';\n        var valueCols = this.columnController.getValueColumns();\n        var aggFuncs = valueCols.map(function (valueCol) { return valueCol.getAggFunc(); });\n        // don't add pivot totals if there is less than 1 aggFunc or they are not all the same\n        if (!aggFuncs || aggFuncs.length < 1 || !this.sameAggFuncs(aggFuncs)) {\n            // console.warn('ag-Grid: aborting adding pivot total columns - value columns require same aggFunc');\n            return;\n        }\n        // arbitrarily select a value column to use as a template for pivot columns\n        var valueColumn = valueCols[0];\n        pivotColumnGroupDefs.forEach(function (groupDef) {\n            _this.recursivelyAddPivotTotal(groupDef, pivotColumnDefs, columnIdSequence, valueColumn, insertAfter);\n        });\n    };\n    PivotColDefService.prototype.recursivelyAddPivotTotal = function (groupDef, pivotColumnDefs, columnIdSequence, valueColumn, insertAfter) {\n        var _this = this;\n        var group = groupDef;\n        if (!group.children)\n            return [groupDef.colId];\n        var colIds = [];\n        // need to recurse children first to obtain colIds used in the aggregation stage\n        group.children\n            .forEach(function (grp) {\n            var childColIds = _this.recursivelyAddPivotTotal(grp, pivotColumnDefs, columnIdSequence, valueColumn, insertAfter);\n            colIds = colIds.concat(childColIds);\n        });\n        // only add total colDef if there is more than 1 child node\n        if (group.children.length > 1) {\n            //create total colDef using an arbitrary value column as a template\n            var totalColDef = this.createColDef(valueColumn, 'Total', groupDef.pivotKeys, columnIdSequence);\n            totalColDef.pivotTotalColumnIds = colIds;\n            totalColDef.aggFunc = valueColumn.getAggFunc();\n            // add total colDef to group and pivot colDefs array\n            var children = groupDef.children;\n            insertAfter ? children.push(totalColDef) : children.unshift(totalColDef);\n            pivotColumnDefs.push(totalColDef);\n        }\n        return colIds;\n    };\n    PivotColDefService.prototype.addRowGroupTotals = function (pivotColumnGroupDefs, pivotColumnDefs, valueColumns, pivotColumns, columnIdSequence) {\n        var _this = this;\n        if (!this.gridOptionsWrapper.getPivotRowTotals())\n            return;\n        var insertAfter = this.gridOptionsWrapper.getPivotRowTotals() === 'after';\n        // order of row group totals depends on position\n        var valueCols = insertAfter ? valueColumns.slice() : valueColumns.slice().reverse();\n        var _loop_1 = function (i) {\n            var valueCol = valueCols[i];\n            var colIds = [];\n            pivotColumnGroupDefs.forEach(function (groupDef) {\n                colIds = colIds.concat(_this.extractColIdsForValueColumn(groupDef, valueCol));\n            });\n            var levelsDeep = pivotColumns.length;\n            this_1.createRowGroupTotal(pivotColumnGroupDefs, pivotColumnDefs, 1, [], columnIdSequence, levelsDeep, pivotColumns, valueCol, colIds, insertAfter);\n        };\n        var this_1 = this;\n        for (var i = 0; i < valueCols.length; i++) {\n            _loop_1(i);\n        }\n    };\n    PivotColDefService.prototype.extractColIdsForValueColumn = function (groupDef, valueColumn) {\n        var _this = this;\n        var group = groupDef;\n        if (!group.children) {\n            var colDef = group;\n            return colDef.pivotValueColumn === valueColumn ? [colDef.colId] : [];\n        }\n        var colIds = [];\n        group.children\n            .forEach(function (grp) {\n            _this.extractColIdsForValueColumn(grp, valueColumn);\n            var childColIds = _this.extractColIdsForValueColumn(grp, valueColumn);\n            colIds = colIds.concat(childColIds);\n        });\n        return colIds;\n    };\n    PivotColDefService.prototype.createRowGroupTotal = function (parentChildren, pivotColumnDefs, index, pivotKeys, columnIdSequence, levelsDeep, primaryPivotColumns, valueColumn, colIds, insertAfter) {\n        var newPivotKeys = pivotKeys.slice(0);\n        var createGroup = index !== levelsDeep;\n        if (createGroup) {\n            var groupDef = {\n                children: [],\n                pivotKeys: newPivotKeys,\n                groupId: 'pivot' + columnIdSequence.next()\n            };\n            insertAfter ? parentChildren.push(groupDef) : parentChildren.unshift(groupDef);\n            this.createRowGroupTotal(groupDef.children, pivotColumnDefs, index + 1, newPivotKeys, columnIdSequence, levelsDeep, primaryPivotColumns, valueColumn, colIds, insertAfter);\n        }\n        else {\n            var measureColumns = this.columnController.getValueColumns();\n            var valueGroup = {\n                children: [],\n                pivotKeys: newPivotKeys,\n                groupId: 'pivot' + columnIdSequence.next()\n            };\n            if (measureColumns.length === 0) {\n                var colDef = this.createColDef(null, '-', newPivotKeys, columnIdSequence);\n                valueGroup.children.push(colDef);\n                pivotColumnDefs.push(colDef);\n            }\n            else {\n                var columnName = this.columnController.getDisplayNameForColumn(valueColumn, 'header');\n                var colDef = this.createColDef(valueColumn, columnName, newPivotKeys, columnIdSequence);\n                colDef.pivotTotalColumnIds = colIds;\n                valueGroup.children.push(colDef);\n                pivotColumnDefs.push(colDef);\n            }\n            insertAfter ? parentChildren.push(valueGroup) : parentChildren.unshift(valueGroup);\n        }\n    };\n    PivotColDefService.prototype.createColDef = function (valueColumn, headerName, pivotKeys, columnIdSequence) {\n        var colDef = {};\n        if (valueColumn) {\n            var colDefToCopy = valueColumn.getColDef();\n            ag_grid_community_1.Utils.assign(colDef, colDefToCopy);\n            // even if original column was hidden, we always show the pivot value column, otherwise it would be\n            // very confusing for people thinking the pivot is broken\n            colDef.hide = false;\n        }\n        colDef.headerName = headerName;\n        colDef.colId = 'pivot_' + columnIdSequence.next();\n        // pivot columns repeat over field, so it makes sense to use the unique id instead. For example if you want to\n        // assign values to pinned bottom rows using setPinnedBottomRowData the value service will use this colId.\n        colDef.field = colDef.colId;\n        colDef.pivotKeys = pivotKeys;\n        colDef.pivotValueColumn = valueColumn;\n        colDef.suppressFilter = true;\n        return colDef;\n    };\n    PivotColDefService.prototype.sameAggFuncs = function (aggFuncs) {\n        if (aggFuncs.length == 1)\n            return true;\n        //check if all aggFunc's match\n        for (var i = 1; i < aggFuncs.length; i++) {\n            if (aggFuncs[i] !== aggFuncs[0])\n                return false;\n        }\n        return true;\n    };\n    PivotColDefService.prototype.headerNameComparator = function (userComparator, a, b) {\n        if (userComparator) {\n            return userComparator(a.headerName, b.headerName);\n        }\n        else {\n            if (a.headerName < b.headerName) {\n                return -1;\n            }\n            else if (a.headerName > b.headerName) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        }\n    };\n    __decorate([\n        ag_grid_community_1.Autowired('columnController'),\n        __metadata(\"design:type\", ag_grid_community_1.ColumnController)\n    ], PivotColDefService.prototype, \"columnController\", void 0);\n    __decorate([\n        ag_grid_community_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", ag_grid_community_1.GridOptionsWrapper)\n    ], PivotColDefService.prototype, \"gridOptionsWrapper\", void 0);\n    PivotColDefService = __decorate([\n        ag_grid_community_1.Bean('pivotColDefService')\n    ], PivotColDefService);\n    return PivotColDefService;\n}());\nexports.PivotColDefService = PivotColDefService;\n",null]}